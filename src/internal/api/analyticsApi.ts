/**
 * Juno
 * Juno Public API Docs
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import http from 'http';
import localVarRequest from 'request';

/* tslint:disable:no-unused-locals */
import { ClickEventResponse } from '../model/clickEventResponse';
import { CustomEventResponse } from '../model/customEventResponse';
import { CustomEventTypeResponse } from '../model/customEventTypeResponse';
import { CustomGraphTypeResponse } from '../model/customGraphTypeResponse';
import { GetAllClickEventsResponse } from '../model/getAllClickEventsResponse';
import { GetAllCustomEventsResponse } from '../model/getAllCustomEventsResponse';
import { GetAllInputEventsResponse } from '../model/getAllInputEventsResponse';
import { GetAllVisitEventsResponse } from '../model/getAllVisitEventsResponse';
import { GetClickEventsResponse } from '../model/getClickEventsResponse';
import { GetCustomEventsResponse } from '../model/getCustomEventsResponse';
import { GetInputEventsResponse } from '../model/getInputEventsResponse';
import { GetVisitEventsResponse } from '../model/getVisitEventsResponse';
import { InputEventResponse } from '../model/inputEventResponse';
import { LogClickEventRequest } from '../model/logClickEventRequest';
import { LogCustomEventRequest } from '../model/logCustomEventRequest';
import { LogInputEventRequest } from '../model/logInputEventRequest';
import { LogVisitEventRequest } from '../model/logVisitEventRequest';
import { VisitEventResponse } from '../model/visitEventResponse';

import {
  Authentication,
  HttpBearerAuth,
  Interceptor,
  ObjectSerializer,
  VoidAuth,
} from '../model/models';

import { HttpError } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AnalyticsApiApiKeys {}

export class AnalyticsApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    API_Key: new HttpBearerAuth(),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AnalyticsApiApiKeys, value: string) {
    (this.authentications as any)[AnalyticsApiApiKeys[key]].apiKey = value;
  }

  set accessToken(accessToken: string | (() => string)) {
    this.authentications.API_Key.accessToken = accessToken;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   *
   * @summary Get all click events
   * @param projectName Project name
   * @param afterTime Filter after timestamp
   * @param limit Max results
   */
  public async analyticsControllerGetAllClickEvents(
    projectName: string,
    afterTime?: string,
    limit?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAllClickEventsResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/events/click/all';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetAllClickEvents.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAllClickEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAllClickEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get all custom events
   * @param projectName Project name
   * @param category Event category
   * @param subcategory Event subcategory
   * @param afterTime Filter after timestamp
   * @param limit Max results
   */
  public async analyticsControllerGetAllCustomEvents(
    projectName: string,
    category: string,
    subcategory: string,
    afterTime?: string,
    limit?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAllCustomEventsResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/events/custom/all';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetAllCustomEvents.'
      );
    }

    // verify required parameter 'category' is not null or undefined
    if (category === null || category === undefined) {
      throw new Error(
        'Required parameter category was null or undefined when calling analyticsControllerGetAllCustomEvents.'
      );
    }

    // verify required parameter 'subcategory' is not null or undefined
    if (subcategory === null || subcategory === undefined) {
      throw new Error(
        'Required parameter subcategory was null or undefined when calling analyticsControllerGetAllCustomEvents.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (category !== undefined) {
      localVarQueryParameters['category'] = ObjectSerializer.serialize(
        category,
        'string'
      );
    }

    if (subcategory !== undefined) {
      localVarQueryParameters['subcategory'] = ObjectSerializer.serialize(
        subcategory,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAllCustomEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAllCustomEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get all input events
   * @param projectName Project name
   * @param afterTime Filter after timestamp
   * @param limit Max results
   */
  public async analyticsControllerGetAllInputEvents(
    projectName: string,
    afterTime?: string,
    limit?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAllInputEventsResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/events/input/all';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetAllInputEvents.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAllInputEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAllInputEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get all visit events
   * @param projectName Project name
   * @param afterTime Filter after timestamp
   * @param limit Max results
   */
  public async analyticsControllerGetAllVisitEvents(
    projectName: string,
    afterTime?: string,
    limit?: number,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetAllVisitEventsResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/events/visit/all';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetAllVisitEvents.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetAllVisitEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetAllVisitEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get click events with pagination
   * @param projectName Project name
   * @param afterId Pagination cursor
   * @param environment Environment filter
   * @param limit Max results
   * @param afterTime Filter after timestamp
   */
  public async analyticsControllerGetClickEventsPaginated(
    projectName: string,
    afterId?: string,
    environment?: string,
    limit?: number,
    afterTime?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetClickEventsResponse }> {
    const localVarPath = this.basePath + '/analytics/events/click';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetClickEventsPaginated.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterId !== undefined) {
      localVarQueryParameters['afterId'] = ObjectSerializer.serialize(
        afterId,
        'string'
      );
    }

    if (environment !== undefined) {
      localVarQueryParameters['environment'] = ObjectSerializer.serialize(
        environment,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetClickEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetClickEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get custom event types for a project
   * @param projectName Project name
   */
  public async analyticsControllerGetCustomEventTypes(
    projectName: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CustomEventTypeResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/custom-event-types';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetCustomEventTypes.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CustomEventTypeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CustomEventTypeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get custom events with pagination
   * @param projectName Project name
   * @param category Event category
   * @param subcategory Event subcategory
   * @param afterId Pagination cursor
   * @param environment Environment filter
   * @param limit Max results
   * @param afterTime Filter after timestamp
   */
  public async analyticsControllerGetCustomEventsPaginated(
    projectName: string,
    category: string,
    subcategory: string,
    afterId?: string,
    environment?: string,
    limit?: number,
    afterTime?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: GetCustomEventsResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/events/custom';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetCustomEventsPaginated.'
      );
    }

    // verify required parameter 'category' is not null or undefined
    if (category === null || category === undefined) {
      throw new Error(
        'Required parameter category was null or undefined when calling analyticsControllerGetCustomEventsPaginated.'
      );
    }

    // verify required parameter 'subcategory' is not null or undefined
    if (subcategory === null || subcategory === undefined) {
      throw new Error(
        'Required parameter subcategory was null or undefined when calling analyticsControllerGetCustomEventsPaginated.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterId !== undefined) {
      localVarQueryParameters['afterId'] = ObjectSerializer.serialize(
        afterId,
        'string'
      );
    }

    if (environment !== undefined) {
      localVarQueryParameters['environment'] = ObjectSerializer.serialize(
        environment,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    if (category !== undefined) {
      localVarQueryParameters['category'] = ObjectSerializer.serialize(
        category,
        'string'
      );
    }

    if (subcategory !== undefined) {
      localVarQueryParameters['subcategory'] = ObjectSerializer.serialize(
        subcategory,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetCustomEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetCustomEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get custom graph types by event type ID
   * @param projectName Project name
   * @param eventTypeId Event type ID
   */
  public async analyticsControllerGetCustomGraphTypesById(
    projectName: string,
    eventTypeId: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{
    response: http.IncomingMessage;
    body: CustomGraphTypeResponse;
  }> {
    const localVarPath = this.basePath + '/analytics/custom-graph-types';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetCustomGraphTypesById.'
      );
    }

    // verify required parameter 'eventTypeId' is not null or undefined
    if (eventTypeId === null || eventTypeId === undefined) {
      throw new Error(
        'Required parameter eventTypeId was null or undefined when calling analyticsControllerGetCustomGraphTypesById.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (eventTypeId !== undefined) {
      localVarQueryParameters['eventTypeId'] = ObjectSerializer.serialize(
        eventTypeId,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CustomGraphTypeResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'CustomGraphTypeResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get input events with pagination
   * @param projectName Project name
   * @param afterId Pagination cursor
   * @param environment Environment filter
   * @param limit Max results
   * @param afterTime Filter after timestamp
   */
  public async analyticsControllerGetInputEventsPaginated(
    projectName: string,
    afterId?: string,
    environment?: string,
    limit?: number,
    afterTime?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetInputEventsResponse }> {
    const localVarPath = this.basePath + '/analytics/events/input';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetInputEventsPaginated.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterId !== undefined) {
      localVarQueryParameters['afterId'] = ObjectSerializer.serialize(
        afterId,
        'string'
      );
    }

    if (environment !== undefined) {
      localVarQueryParameters['environment'] = ObjectSerializer.serialize(
        environment,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetInputEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetInputEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get visit events with pagination
   * @param projectName Project name
   * @param afterId Pagination cursor
   * @param environment Environment filter
   * @param limit Max results
   * @param afterTime Filter after timestamp
   */
  public async analyticsControllerGetVisitEventsPaginated(
    projectName: string,
    afterId?: string,
    environment?: string,
    limit?: number,
    afterTime?: string,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: GetVisitEventsResponse }> {
    const localVarPath = this.basePath + '/analytics/events/visit';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'projectName' is not null or undefined
    if (projectName === null || projectName === undefined) {
      throw new Error(
        'Required parameter projectName was null or undefined when calling analyticsControllerGetVisitEventsPaginated.'
      );
    }

    if (projectName !== undefined) {
      localVarQueryParameters['projectName'] = ObjectSerializer.serialize(
        projectName,
        'string'
      );
    }

    if (afterId !== undefined) {
      localVarQueryParameters['afterId'] = ObjectSerializer.serialize(
        afterId,
        'string'
      );
    }

    if (environment !== undefined) {
      localVarQueryParameters['environment'] = ObjectSerializer.serialize(
        environment,
        'string'
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters['limit'] = ObjectSerializer.serialize(
        limit,
        'number'
      );
    }

    if (afterTime !== undefined) {
      localVarQueryParameters['afterTime'] = ObjectSerializer.serialize(
        afterTime,
        'string'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'GET',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetVisitEventsResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                'GetVisitEventsResponse'
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Log a click event
   * @param logClickEventRequest
   */
  public async analyticsControllerLogClickEvent(
    logClickEventRequest: LogClickEventRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: ClickEventResponse }> {
    const localVarPath = this.basePath + '/analytics/events/click';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'logClickEventRequest' is not null or undefined
    if (logClickEventRequest === null || logClickEventRequest === undefined) {
      throw new Error(
        'Required parameter logClickEventRequest was null or undefined when calling analyticsControllerLogClickEvent.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        logClickEventRequest,
        'LogClickEventRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ClickEventResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'ClickEventResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Log a custom event
   * @param logCustomEventRequest
   */
  public async analyticsControllerLogCustomEvent(
    logCustomEventRequest: LogCustomEventRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: CustomEventResponse }> {
    const localVarPath = this.basePath + '/analytics/events/custom';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'logCustomEventRequest' is not null or undefined
    if (logCustomEventRequest === null || logCustomEventRequest === undefined) {
      throw new Error(
        'Required parameter logCustomEventRequest was null or undefined when calling analyticsControllerLogCustomEvent.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        logCustomEventRequest,
        'LogCustomEventRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CustomEventResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'CustomEventResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Log an input event
   * @param logInputEventRequest
   */
  public async analyticsControllerLogInputEvent(
    logInputEventRequest: LogInputEventRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: InputEventResponse }> {
    const localVarPath = this.basePath + '/analytics/events/input';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'logInputEventRequest' is not null or undefined
    if (logInputEventRequest === null || logInputEventRequest === undefined) {
      throw new Error(
        'Required parameter logInputEventRequest was null or undefined when calling analyticsControllerLogInputEvent.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        logInputEventRequest,
        'LogInputEventRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: InputEventResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'InputEventResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Log a visit event
   * @param logVisitEventRequest
   */
  public async analyticsControllerLogVisitEvent(
    logVisitEventRequest: LogVisitEventRequest,
    options: { headers: { [name: string]: string } } = { headers: {} }
  ): Promise<{ response: http.IncomingMessage; body: VisitEventResponse }> {
    const localVarPath = this.basePath + '/analytics/events/visit';
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders
    );
    const produces = ['application/json'];
    // give precedence to 'application/json'
    if (produces.indexOf('application/json') >= 0) {
      localVarHeaderParams.Accept = 'application/json';
    } else {
      localVarHeaderParams.Accept = produces.join(',');
    }
    let localVarFormParams: any = {};

    // verify required parameter 'logVisitEventRequest' is not null or undefined
    if (logVisitEventRequest === null || logVisitEventRequest === undefined) {
      throw new Error(
        'Required parameter logVisitEventRequest was null or undefined when calling analyticsControllerLogVisitEvent.'
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: 'POST',
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        logVisitEventRequest,
        'LogVisitEventRequest'
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.API_Key.accessToken) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.API_Key.applyToRequest(localVarRequestOptions)
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions)
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions)
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: VisitEventResponse;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, 'VisitEventResponse');
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
